# Flappy Bird

经典小游戏，就不介绍了

时间：2020.4.14

## 坑の总结

1. 关于输出，各种输出函数的速度大概是`putchar > printf > cout`，原因还需进一步的学习。另外windows库的输出(各种`WriteConsoleOutput`)快到离谱。因此，在用向控制台输出的方式显示游戏画面时，用windows的api比较好, `putchar`都会卡成ppt, 更不用说其他两个。

2. 关于画面更新的问题。之前我采用的方式是`system(“cls”)`清屏, 然后再绘制新的画面。这样的结果是有时候能够明显看出画面闪烁(而且这黑底白字还有视觉暂留)，简直辣眼睛。最后，我采用的方法是用一个`image`字符数组暂时存储上一帧的图像，然后生成这一帧的图像之后，先不输出，逐一和上一针进行对比，不一样的地方再用`printChar()`函数在指定位置输出。

3. 由于上一个方法定义了一个和游戏界面大小相同的数组，因此判断越界显得格外重要。尊重原游戏的设定，小鸟飞出屏幕框不会死亡(除了碰到底面，但是我懒，就都没判定成死亡)，这时对于小鸟坐标在`image`当中的更新要特判。

4. 定义pair两个量的顺序一！定！要！统！一！下面是节选的程序:

   ```c++
   class Bird
   {
   private:
       pair<float, float> XY;
       float speed; //鸟的速度, 上为正方向
       float a;     //鸟的加速度
   }
   
   class Pillar
   {
   private:
       deque<pair<float, int>> pillars; //柱子的坐标(左)和缺口的坐标(上)
       float speed;                     //柱子移动的速度, 左为正方向
   }
   ```

   可以看出，这里鸟的坐标XY和deque的坐标顺序(横向和纵向的顺序，我的习惯是先行后列，XY分别是行号和列号)是反着的，原因是我在一开始码代码时没有想到缺口的逻辑，pillars只包含柱子横向的坐标。

   虽然在之后程序的编写当中我格外注意，并没有出问题，但是当代码量上升时，出bug的概率会大大增加，这样的问题是一定要避免的。